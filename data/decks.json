[
  {
    "id": "section-1",
    "title": "Data Intensive Apps",
    "decks": [
      {
        "id": "deck-1",
        "title": "Data-Intensive Basics",
        "cards": [
          {
            "id": 101,
            "displayId": "BAS-01",
            "front": "What is **Reliability** in system design?",
            "back": "The ability of a system to continue to work *correctly* even when things go wrong.\n\n### Key aspects:\n- Fault tolerance\n- Hardware redundancy\n- Error handling.\n\n",
            "category": "Basics",
            "frontImage": null,
            "backImage": "data:image/png;base64,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"
          },
          {
            "id": 102,
            "displayId": "BAS-02",
            "front": "What does the **CAP Theorem** state for a system $S$?",
            "back": "In a distributed system, you can only provide two out of three:\n1. **Consistency** ($C$)\n2. **Availability** ($A$)\n3. **Partition Tolerance** ($P$)\n\n$\\text{If } P \\text{ exists} \\implies (C \\lor A)$ \n\nThis forces a trade-off during a network partition.",
            "category": "Consistency",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-2",
        "title": "Chapter 2: Data Models",
        "cards": [
          {
            "id": 201,
            "displayId": "MOD-01",
            "front": "Explain **Impedance Mismatch**.",
            "back": "The disconnect between the object-oriented model in application code and the relational model (tables/rows) in databases. \n\n$Objects \\neq Tables$\n\nOften requires an ORM layer.",
            "category": "Concepts",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-3",
        "title": "Chapter 3: Storage Engines",
        "cards": [
          {
            "id": 301,
            "displayId": "STO-01",
            "front": "Analyze the time complexity of a **B-Tree** lookup.",
            "back": "For a B-tree with $n$ elements and branching factor $b$:\n- Depth is $O(\\log_b n)$\n- Lookup is $O(\\log_b n)$\n\n`Index seeks` are minimized due to the high $b$, making it very disk-efficient.",
            "category": "Engines",
            "frontImage": null,
            "backImage": null
          }
        ]
      }
    ]
  },
  {
    "id": "section-2",
    "title": "Introduction to Computer Science with Java",
    "decks": [
      {
        "id": "deck-4",
        "title": "Chapter 1: Fundamentals of Programming and Variables",
        "cards": [
          {
            "id": 1001,
            "displayId": "VAR-01",
            "front": "What are the **eight primitive types** in Java?",
            "back": "The eight primitive types in Java are:\n1. **byte** - 8-bit signed integer\n2. **short** - 16-bit signed integer\n3. **int** - 32-bit signed integer\n4. **long** - 64-bit signed integer\n5. **float** - 32-bit floating-point\n6. **double** - 64-bit floating-point\n7. **boolean** - true or false\n8. **char** - 16-bit Unicode character\n\nThese store values directly in memory, unlike reference types which store object references.  ",
            "category": "Primitive Types",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 1002,
            "displayId": "VAR-02",
            "front": "What is the difference between **variable declaration** and **variable initialization** in Java?",
            "back": "**Declaration** introduces a variable with a specific type and name, reserving memory space. Example: `int age;`\n\n**Initialization** assigns an initial value to that variable. Example: `age = 25;`\n\nThese can be combined: `int age = 25;` declares and initializes in one statement. A variable must be declared before use, but initialization is optional for some types (though it's best practice to initialize).",
            "category": "Variables",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 1003,
            "displayId": "VAR-03",
            "front": "What is **variable scope** in Java, and why is it important?",
            "back": "Variable scope refers to the region of code where a variable can be accessed. In Java, the main scope types are:\n\n- **Local scope**: Variables declared inside a method are only accessible within that method\n- **Class/Instance scope**: Variables declared as class fields are accessible throughout the class\n- **Block scope**: Variables declared inside a block (if, for, while) are only accessible within that block\n\nScope is important because it prevents naming conflicts, improves code organization, and ensures variables are only used where appropriate. Improper scope can lead to bugs and unintended variable access.",
            "category": "Variables",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 1004,
            "displayId": "VAR-04",
            "front": "What is the purpose of the **`final` keyword** when declaring a variable in Java?",
            "back": "The `final` keyword declares a variable as a **constant**, meaning its value cannot be changed once initialized.\n\nExample: `final double PI = 3.14159;`\n\nKey points:\n- The variable must be initialized when declared or in the constructor\n- Attempting to reassign a final variable results in a compile-time error\n- By convention, final variables are named in ALL_UPPERCASE\n- Using `final` improves code safety, enables compiler optimizations, and makes intent clear\n- Often used for mathematical constants, configuration values, and immutable references",
            "category": "Variables",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-5",
        "title": "Chapter 2: Control Flow and Functions",
        "cards": [
          {
            "id": 2001,
            "displayId": "CTL-01",
            "front": "What is the purpose of an **if-else statement** in Java?",
            "back": "An if-else statement allows a program to execute different code blocks based on whether a condition is true or false. The if block executes when the condition is true, and the else block (if present) executes when the condition is false. This enables conditional branching in program logic.",
            "category": "ControlFlow",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 2002,
            "displayId": "CTL-02",
            "front": "Explain the difference between a **for loop** and a **while loop** in Java.",
            "back": "A **for loop** is used when you know the number of iterations upfront. It has a definite structure: initialization, condition, and increment. A **while loop** continues executing as long as its condition remains true, making it ideal when the number of iterations is unknown or depends on dynamic conditions. For loops are generally preferred for counting iterations, while loops for event-driven repetition.",
            "category": "ControlFlow",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 2003,
            "displayId": "CTL-03",
            "front": "What are the key components of a **method definition** in Java? Provide an example.",
            "back": "A method definition consists of:\n- **Access modifier** (public, private)\n- **Return type** (void, int, String, etc.)\n- **Method name** (should be descriptive)\n- **Parameters** (optional, in parentheses)\n- **Method body** (enclosed in curly braces)\n\nExample:\n```java\npublic int calculateSum(int a, int b) {\n  return a + b;\n}\n```\nThis method is public, returns an int, takes two int parameters, and returns their sum.",
            "category": "Functions",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 2004,
            "displayId": "CTL-04",
            "front": "Explain **parameter passing** in Java. What is the difference between passing primitive types and objects?",
            "back": "Java uses **pass-by-value** for both primitive types and objects, but with different implications:\n\n**Primitive types** (int, double, boolean, etc.): The actual value is copied and passed to the method. Changes made inside the method do not affect the original variable.\n\n**Objects**: A copy of the reference (memory address) is passed, not the object itself. Changes to the object's properties inside the method affect the original object, but reassigning the parameter variable does not affect the original reference.\n\nCorrect approach:\n```java\nvoid changeObject(MyClass obj) { obj.property = 5; } // ✅ affects caller's object\n```\n\nIncorrect approach:\n```java\nvoid changePrimitive(int x) { x = 10; } // ❌ doesn't affect caller's x\n```",
            "category": "Functions",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 2005,
            "displayId": "TEST-01",
            "front": "What is a **simple Java class with syntax highlighting**?",
            "back": "Here's a correctly implemented Bank class:\n\n```java\npublic class BankAccount {\n  private double balance;\n  \n  public BankAccount(double initialBalance) { // ✅ proper constructor\n    this.balance = initialBalance;\n  }\n  \n  public void withdraw(double amount) {\n    if (amount > 0 && amount <= balance) { // ✅ proper validation\n      balance -= amount;\n    }\n  }\n}\n```\n\nHere's an incorrect implementation:\n\n```java\npublic class BadBank {\n  public double balance; // ❌ should be private\n  \n  public void withdraw(double amount) {\n    balance = balance - amount; // ❌ no validation\n  }\n}\n```",
            "category": "Examples",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-6",
        "title": "Chapter 3: Object-Oriented Programming",
        "cards": [
          {
            "id": 3001,
            "displayId": "OOP-01",
            "front": "What is the difference between a **class** and an **object** in Java?",
            "back": "A **class** is a blueprint or template that defines the structure and behavior of objects. An **object** is an instance of a class - a concrete realization created from that blueprint. Example: `String` is a class, while `\"Hello\"` is an object (instance) of the String class.",
            "category": "OOP",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 3002,
            "displayId": "OOP-02",
            "front": "Explain **encapsulation** and how it is implemented in Java using access modifiers.",
            "back": "**Encapsulation** is bundling data (fields) and methods together within a class while hiding internal details. It is implemented using access modifiers:\n- `private` - accessible only within the class\n- `public` - accessible from anywhere\n- `protected` - accessible within package and subclasses\n- package-private (default) - accessible within the package\n\nThis protects data from unauthorized access and modification.",
            "category": "OOP",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 3003,
            "displayId": "OOP-03",
            "front": "What are **inheritance** and **method overriding**? Provide an example.",
            "back": "**Inheritance** allows a subclass to inherit properties and methods from a superclass using the `extends` keyword.\n\n**Method overriding** occurs when a subclass provides its own implementation of a method defined in the superclass.\n\nExample:\n```java\nclass Animal {\n  void speak() { System.out.println(\"Some sound\"); }\n}\nclass Dog extends Animal {\n  @Override\n  void speak() { System.out.println(\"Woof!\"); }\n}\n```\nDog overrides the `speak()` method with its own implementation.",
            "category": "OOP",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 3004,
            "displayId": "OOP-04",
            "front": "Define **polymorphism** and explain its two main types with examples.",
            "back": "**Polymorphism** means \"many forms\" - the ability of objects to take multiple forms or methods to behave differently based on context.\n\n**Compile-time Polymorphism (Method Overloading):**\nMultiple methods with the same name but different parameters.\n```java\nvoid print(int x) { }\nvoid print(String x) { }\n```\n\n**Runtime Polymorphism (Method Overriding):**\nA subclass method overrides the superclass method. The actual method called depends on the object type at runtime.\n```java\nAnimal animal = new Dog();\nanimal.speak(); // Calls Dog's speak(), not Animal's\n```",
            "category": "OOP",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-7",
        "title": "Chapter 4: Collections and Data Structures",
        "cards": [
          {
            "id": 4001,
            "displayId": "COL-01",
            "front": "What is the time complexity of **ArrayList.get(index)**?",
            "back": "$O(1)$ - constant time.\n\nArrayList stores elements in a contiguous array, so accessing by index is direct memory access, regardless of the list size.",
            "category": "Collections",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 4002,
            "displayId": "COL-02",
            "front": "Compare the time complexity of **add()** for ArrayList vs LinkedList at the end.",
            "back": "- **ArrayList**: $O(1)$ amortized time. Appending to the end is constant unless resizing is needed.\n- **LinkedList**: $O(1)$ constant time. Adding at the end only requires updating the tail pointer.\n\nBoth are efficient for end insertions, but ArrayList is generally faster in practice due to cache locality.",
            "category": "Collections",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 4003,
            "displayId": "COL-03",
            "front": "What is the time complexity of **HashMap.get(key)** and **HashMap.put(key, value)**?",
            "back": "Both average $O(1)$ - constant time.\n\nHashMap uses a hash function to directly locate the bucket containing the key-value pair. In the worst case (all collisions), performance degrades to $O(n)$, but this is rare with a good hash function and proper load factor management.",
            "category": "Collections",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 4004,
            "displayId": "COL-04",
            "front": "What are the key differences between **Set** and **List**?",
            "back": "| Property | Set | List |\n|----------|-----|------|\n| **Duplicates** | Not allowed | Allowed |\n| **Order** | No guaranteed order (unless TreeSet) | Maintains insertion order |\n| **Access** | No index-based access | Index-based access via get() |\n| **Common Implementations** | HashSet, TreeSet | ArrayList, LinkedList |\n\n**Set** is optimized for membership testing ($O(1)$ for HashSet), while **List** is optimized for sequential access and positional operations.",
            "category": "Collections",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-8",
        "title": "Chapter 5: Exception Handling and I/O",
        "cards": [
          {
            "id": 5001,
            "displayId": "EXC-01",
            "front": "What is the difference between **checked** and **unchecked** exceptions in Java?",
            "back": "**Checked exceptions** (e.g., IOException, SQLException) must be caught or declared in the method signature using `throws`. They are checked at compile-time. **Unchecked exceptions** (e.g., NullPointerException, ArrayIndexOutOfBoundsException) are subclasses of RuntimeException and don't require explicit handling - they are checked at runtime.",
            "category": "ExceptionHandling",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 5002,
            "displayId": "EXC-02",
            "front": "Explain the structure and purpose of a **try-catch-finally** block. What code goes in each section?",
            "back": "- **try block**: Contains code that may throw an exception\n- **catch block(s)**: Handles specific exception types; executes only if the corresponding exception is thrown\n- **finally block**: Optional; executes regardless of whether an exception occurred, typically used for cleanup (closing files, releasing resources)\n\nExample:\n```java\ntry {\n  // risky code\n} catch (IOException e) {\n  // handle IO error\n} finally {\n  // cleanup code\n}\n```",
            "category": "ExceptionHandling",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 5003,
            "displayId": "EXC-03",
            "front": "What is a **stream** in Java I/O, and what are the two main categories of streams?",
            "back": "A **stream** is a sequence of data flowing from a source to a destination. The two main categories are:\n\n1. **Byte Streams**: Handle raw binary data (e.g., FileInputStream, FileOutputStream, InputStream, OutputStream). Suitable for images, audio, and binary files.\n2. **Character Streams**: Handle text data (e.g., FileReader, FileWriter, Reader, Writer). Suitable for text files. Character streams use Unicode encoding.\n\nCharacter streams are typically wrappers around byte streams with built-in encoding/decoding.",
            "category": "FileIO",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 5004,
            "displayId": "EXC-04",
            "front": "What are the best practices for error handling and resource management in Java?",
            "back": "**Best practices for error handling:**\n1. Catch specific exceptions rather than generic Exception\n2. Provide meaningful error messages for debugging\n3. Log exceptions appropriately\n4. Use try-with-resources for automatic resource cleanup:\n```java\ntry (FileReader fr = new FileReader(\"file.txt\")) {\n  // use fr\n} catch (IOException e) {\n  // handle error\n}\n```\n5. Clean up resources in finally blocks or use try-with-resources\n6. Don't suppress exceptions silently; handle or re-throw appropriately\n7. Distinguish between recoverable errors (catch and handle) and fatal errors (let propagate)\n8. Create custom exceptions for application-specific errors",
            "category": "ErrorHandling",
            "frontImage": null,
            "backImage": null
          }
        ]
      }
    ]
  },
  {
    "id": "section-3",
    "title": "Git Introduction",
    "decks": [
      {
        "id": "deck-9",
        "title": "Chapter 1: Git Basics and Configuration",
        "cards": [
          {
            "id": 6001,
            "displayId": "GIT-01",
            "front": "What is **Git** and why is it important in software development?",
            "back": "**Git** is a distributed version control system (VCS) that tracks changes to files over time. It allows multiple developers to work on the same project simultaneously without conflicts.\n\n**Why it's important:**\n- **History tracking**: See who changed what and when\n- **Collaboration**: Multiple developers can work together\n- **Branching**: Experiment with features independently\n- **Rollback**: Revert to previous versions if needed\n- **Distributed**: Each developer has a complete copy of the project history\n\nGit is the industry standard for version control in modern software development.",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6002,
            "displayId": "GIT-02",
            "front": "What is **version control** and what problems does it solve?",
            "back": "**Version control** is a system that records changes to files over time, allowing you to track and manage different versions of your project.\n\n**Problems it solves:**\n- **Tracking changes**: Know exactly what changed, who changed it, and why\n- **Collaboration conflicts**: Merge changes from multiple developers safely\n- **Accidental deletions**: Recover lost code from previous commits\n- **Feature development**: Work on features independently without affecting main codebase\n- **Code review**: Review changes before merging them\n- **Release management**: Maintain multiple versions of software simultaneously\n\nWithout version control, developers would struggle with file naming (v1, v2, final, final_final) and lose the ability to understand code evolution.",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6003,
            "displayId": "GIT-03",
            "front": "What does `git init` do and when would you use it?",
            "back": "**`git init`** initializes a new Git repository in the current directory.\n\n**What it does:**\n- Creates a hidden `.git` folder containing all Git configuration and history\n- Sets up the necessary Git infrastructure to start tracking files\n- Initializes the default branch (usually `main` or `master`)\n\n**When to use it:**\n- Starting a new project from scratch\n- Converting an existing project folder to a Git repository\n- Initializing a local repository before pushing to a remote (e.g., GitHub)\n\n**Example:**\n```bash\nmkdir my-project\ncd my-project\ngit init\n```\n\nAfter this, you can start adding and committing files to version control.",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6004,
            "displayId": "GIT-04",
            "front": "What is **`git config`** and what are the three configuration levels in Git?",
            "back": "**`git config`** is a command that sets and retrieves configuration variables for Git. It controls Git behavior like user identity, editor preferences, and merge strategies.\n\n**Three configuration levels:**\n\n1. **System** (`--system`): Applies to all users on the computer. Config file: `/etc/gitconfig`\n```bash\ngit config --system user.name \"Company Name\"\n```\n\n2. **Global** (`--global`): Applies to the current user. Config file: `~/.gitconfig`\n```bash\ngit config --global user.name \"Your Name\"\n```\n\n3. **Local** (`--local`): Applies only to the current repository. Config file: `.git/config`\n```bash\ngit config --local user.email \"project-specific@example.com\"\n```\n\n**Priority order**: Local → Global → System (local overrides global, which overrides system).\n\n**Common configs:**\n```bash\ngit config --global user.name \"John Doe\"\ngit config --global user.email \"john@example.com\"\n```",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6005,
            "displayId": "GIT-05",
            "front": "What does `git status` show and why is it useful?",
            "back": "**`git status`** displays the current state of your working directory and staging area.\n\n**What it shows:**\n- **Current branch**: Which branch you're on\n- **Untracked files**: New files not yet added to Git\n- **Modified files**: Files changed but not staged for commit\n- **Staged files**: Files ready to be committed\n- **Commits ahead/behind**: How many commits ahead/behind the remote branch\n\n**Example output:**\n```\nOn branch main\nChanges to be committed:\n  new file: app.js\n\nChanges not staged for commit:\n  modified: README.md\n\nUntracked files:\n  config.json\n```\n\n**Why it's useful:**\n- See what changes you've made before committing\n- Avoid accidentally committing sensitive files\n- Understand the current state of your repository\n- Plan your next commit\n\n**Pro tip**: Run `git status` frequently during development to stay aware of changes.",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6006,
            "displayId": "GIT-06",
            "front": "Explain the difference between `git add` and `git commit`. What is the **staging area**?",
            "back": "**Staging area** (also called *index*) is an intermediate step between your working directory and the repository. It lets you choose exactly which changes to include in your next commit.\n\n**`git add`** moves changes from the working directory to the staging area:\n```bash\ngit add filename        # Add specific file\ngit add .               # Add all modified files\ngit add *.js            # Add all .js files\n```\n\n**`git commit`** takes staged changes and saves them permanently to the repository:\n```bash\ngit commit -m \"Your message here\"\n```\n\n**Workflow:**\n```\nWorking Directory → git add → Staging Area → git commit → Repository\n```\n\n**Why this two-step process?**\n- **Precision**: Commit only related changes, leaving other work uncommitted\n- **Code review**: Review staged changes before committing\n- **Atomic commits**: Create meaningful, focused commits rather than \"dump everything\"\n\n**Example:**\n```bash\ngit add feature.js\ngit add tests/feature.test.js\ngit commit -m \"Add new feature with tests\"\n# docs.md is modified but not committed\n```",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6007,
            "displayId": "GIT-07",
            "front": "What is `.gitignore` and provide examples of files that should typically be ignored?",
            "back": "**`.gitignore`** is a special file that tells Git which files and directories to ignore (not track).\n\n**Files to typically ignore:**\n- **Dependencies**: `node_modules/`, `venv/`, `.gradle/`\n- **Build outputs**: `dist/`, `build/`, `*.o`, `*.class`\n- **IDE settings**: `.vscode/`, `.idea/`, `*.swp`\n- **Environment files**: `.env`, `.env.local`, `secrets.json`\n- **OS files**: `.DS_Store`, `Thumbs.db`\n- **Logs**: `*.log`, `logs/`\n- **Cache**: `.cache/`, `tmp/`\n\n**Example `.gitignore` file:**\n```\n# Dependencies\nnode_modules/\nvenv/\n\n# Environment variables\n.env\n.env.local\n\n# IDE\n.vscode/\n.idea/\n\n# OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\n```\n\n**Rules:**\n- Lines starting with `#` are comments\n- `*.ext` matches all files with that extension\n- `folder/` matches a directory and its contents\n- `!important.txt` uses `!` to exclude from ignore\n\n**Important**: Add `.gitignore` early in the project to prevent accidentally committing sensitive data.",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6008,
            "displayId": "GIT-08",
            "front": "What does `git log` do and what are common options to view commit history?",
            "back": "**`git log`** displays the commit history of your repository, showing previous commits with metadata.\n\n**What it shows for each commit:**\n- Commit hash (SHA-1 identifier)\n- Author name and email\n- Date and time\n- Commit message\n\n**Common options:**\n\n```bash\ngit log                          # Full commit history\ngit log --oneline                # One line per commit (compact)\ngit log -n 5                      # Last 5 commits\ngit log --graph --all --oneline  # Visual branch graph\ngit log --author=\"John\"          # Commits by specific author\ngit log --since=\"2 weeks ago\"    # Commits in time range\ngit log filename                 # History of specific file\ngit log -p                       # Show full diffs of each commit\n```\n\n**Example output with `--oneline`:**\n```\ne0cb827 Add Git introduction flashcards\nbf64fc8 Add Java flashcards\nb5cfc07 First commit\n```\n\n**Why it's useful:**\n- Understand project history and evolution\n- Track when features were added or bugs were introduced\n- Review commit messages and author information\n- Investigate which commit caused a problem",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6009,
            "displayId": "GIT-09",
            "front": "What does `git diff` show and how do you use it to compare changes?",
            "back": "**`git diff`** shows line-by-line differences between file versions, helping you understand exactly what changed.\n\n**Common usage:**\n\n```bash\ngit diff                    # Unstaged changes (working dir vs staging area)\ngit diff --staged           # Staged changes (staging area vs last commit)\ngit diff HEAD               # All changes since last commit\ngit diff HEAD~1             # Changes in the last commit\ngit diff branch1 branch2    # Differences between two branches\ngit diff filename           # Changes in specific file\n```\n\n**Example output:**\n```\ndiff --git a/app.js b/app.js\nindex 1234567..abcdefg 100644\n--- a/app.js\n+++ b/app.js\n@@ -5,3 +5,5 @@\n const express = require('express');\n const app = express();\n+const PORT = 3000;\n+app.listen(PORT);\n```\n\nThe `+` prefix shows added lines, `-` shows deleted lines, context lines have no prefix.\n\n**Why it's useful:**\n- Review changes before staging or committing\n- Understand what modified files contain\n- Debug unintended changes\n- Code review process\n- Identify exactly what lines changed between commits",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6010,
            "displayId": "GIT-10",
            "front": "Explain the typical Git workflow: initialize, add, commit, and view history.",
            "back": "**Complete Git workflow for a new project:**\n\n**1. Initialize repository:**\n```bash\ngit init\n```\n\n**2. Configure Git (first time only):**\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n```\n\n**3. Create or modify files** in your working directory.\n\n**4. Check status:**\n```bash\ngit status  # See what changed\n```\n\n**5. Review changes:**\n```bash\ngit diff    # See line-by-line changes\n```\n\n**6. Stage changes:**\n```bash\ngit add file.js         # Add specific file\ngit add .               # Add all changes\n```\n\n**7. Commit with message:**\n```bash\ngit commit -m \"Descriptive message about your changes\"\n```\n\n**8. View history:**\n```bash\ngit log --oneline\n```\n\n**Repeat steps 3-7** for each set of logical changes.\n\n**Best practices:**\n- Commit frequently with focused changes\n- Write clear, descriptive commit messages\n- Run `git status` and `git diff` before committing\n- Keep commits atomic (one feature/fix per commit)\n- Use `.gitignore` from the start",
            "category": "Git Basics",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-10",
        "title": "Chapter 2: Branching and Merging",
        "cards": [
          {
            "id": 6011,
            "displayId": "GIT-11",
            "front": "What is a **git branch** and why would you create one?",
            "back": "A **git branch** is an independent line of development that allows you to work on features or fixes without affecting the main codebase. Branches are pointers to commits and enable:\n- Parallel development by multiple developers\n- Isolation of experimental features\n- Easy cleanup and organization\n- Safer integration via pull requests\n\nExample: `git branch feature/login-page` creates a new branch.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6012,
            "displayId": "GIT-12",
            "front": "What is the difference between `git checkout` and `git switch`?",
            "back": "Both commands switch branches, but they have different purposes:\n\n**`git checkout [branch]`**: Legacy command that switches branches and can also checkout files or commits. It's a multi-purpose command that can be confusing.\n\n**`git switch [branch]`**: Modern command (Git 2.23+) specifically designed for switching branches. It's clearer in intent and safer.\n\nExample:\n```bash\ngit checkout main     # Legacy way\ngit switch main       # Modern way (preferred)\n```\n\nUse `git switch` in new projects for clarity.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6013,
            "displayId": "GIT-13",
            "front": "How do you create a new branch and switch to it in one command?",
            "back": "You can use either of these commands:\n\n**Using `git checkout`:**\n```bash\ngit checkout -b feature/new-feature\n```\n\n**Using `git switch`:**\n```bash\ngit switch -c feature/new-feature\n```\n\nBoth create a new branch based on the current HEAD and switch to it immediately. The `-b` flag in `checkout` and `-c` flag in `switch` both mean \"create and switch.\"\n\nThe `git switch` approach is recommended for modern Git workflows.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6014,
            "displayId": "GIT-14",
            "front": "What are **git branch naming conventions** and why are they important?",
            "back": "Branch naming conventions improve code organization and team communication. Common patterns:\n\n**Feature branches:**\n```\nfeature/user-authentication\nfeature/payment-integration\n```\n\n**Bug fix branches:**\n```\nbugfix/fix-login-error\nhotfix/critical-security-patch\n```\n\n**Other types:**\n```\nrefactor/update-database-layer\ndocs/api-documentation\n```\n\n**Best practices:**\n- Use lowercase letters and hyphens (no spaces)\n- Be descriptive but concise\n- Prefix with type: feature/, bugfix/, hotfix/, refactor/, docs/\n- Avoid special characters that might cause shell issues\n\nThese conventions make logs readable and help teams understand branch purpose at a glance.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6015,
            "displayId": "GIT-15",
            "front": "Explain **git merge** and the two common merge strategies.",
            "back": "**`git merge`** integrates changes from one branch into another. It combines the commit history of both branches.\n\n**Common merge strategies:**\n\n1. **Three-way merge** (standard):\n   ```bash\n   git merge feature/new-feature\n   ```\n   Creates a new merge commit combining both branch histories. Results in a merge commit that references both parents.\n\n2. **Squash merge** (flatten history):\n   ```bash\n   git merge --squash feature/new-feature\n   ```\n   Combines all commits from the branch into a single commit. Keeps history clean but loses individual commit details.\n\n**Three-way merge** is used when you want to preserve full history. **Squash merge** is useful for feature branches with many small commits.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6016,
            "displayId": "GIT-16",
            "front": "What is a **merge conflict** and how do you resolve it?",
            "back": "A **merge conflict** occurs when Git cannot automatically merge changes because both branches modified the same lines in the same file.\n\n**How to resolve:**\n\n1. Run `git merge` and Git will notify you of conflicts\n2. Open the conflicted files - they contain markers:\n   ```\n   <<<<<<< HEAD\n   your changes\n   =======\n   their changes\n   >>>>>>> feature/branch\n   ```\n3. Manually edit the file to keep desired changes, remove markers\n4. Stage the resolved files:\n   ```bash\n   git add filename\n   ```\n5. Complete the merge:\n   ```bash\n   git commit -m \"Merge feature/branch with conflict resolution\"\n   ```\n\n**Prevention:** Communicate with teammates, keep branches short-lived, and rebase frequently to avoid divergence.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6017,
            "displayId": "GIT-17",
            "front": "What is a **fast-forward merge** and when does it occur?",
            "back": "A **fast-forward merge** occurs when the target branch has no new commits since the source branch was created. Git simply moves the branch pointer forward without creating a merge commit.\n\n**Example:**\n```\nInitial state:\nmain:        A --- B --- C\nfeature:          └─── D --- E\n\nAfter git merge feature (fast-forward):\nmain:        A --- B --- C --- D --- E\n```\n\n**When it occurs:**\n- The target branch (main) has no commits after the source branch diverged\n- No new work was done on the target branch\n\n**To prevent fast-forward merge:**\n```bash\ngit merge --no-ff feature/branch\n```\nThis creates a merge commit even if fast-forward is possible. Useful for maintaining explicit branch history.\n\n**Advantage of fast-forward:** Cleaner, linear history.\n**Disadvantage:** Loses information about the branch that was merged.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6018,
            "displayId": "GIT-18",
            "front": "What is **git rebase** and how does it differ from **git merge**?",
            "back": "**`git rebase`** reapplies commits from one branch onto another by replaying them on top of the target branch.\n\n**Example:**\n```\nBefore rebase:\nmain:        A --- B --- C\nfeature:          └─── D --- E\n\nAfter git rebase main:\nmain:        A --- B --- C\nfeature:              └─── D' --- E'\n```\nCommits D and E are replayed on top of C, creating new commits D' and E'.\n\n**git merge vs git rebase:**\n\n| Aspect | Merge | Rebase |\n|--------|-------|--------|\n| **History** | Creates merge commit, preserves both histories | Rewrites history, linear progression |\n| **Readability** | Non-linear, shows branch structure | Clean, linear history |\n| **Collaboration** | Safe for shared branches | **Never rebase shared/public branches** |\n| **Debugging** | Easier to see feature branches | Harder to trace feature history |\n\n**Best practice:** Use `rebase` for local branches before pushing, use `merge` for shared branches.",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6019,
            "displayId": "GIT-19",
            "front": "How do you delete a git branch both locally and remotely?",
            "back": "**Delete local branch:**\n```bash\ngit branch -d feature/completed-feature      # Safe delete (warns if not merged)\ngit branch -D feature/completed-feature      # Force delete\n```\nThe `-d` flag is safe - it warns if the branch hasn't been merged. Use `-D` to force delete.\n\n**Delete remote branch:**\n```bash\ngit push origin --delete feature/completed-feature\n# Or alternative syntax:\ngit push origin :feature/completed-feature\n```\n\n**Delete both local and remote at once:**\n```bash\ngit branch -d feature/completed-feature && git push origin --delete feature/completed-feature\n```\n\n**Important:** Always ensure the branch is merged before deleting, or you'll lose work. To check:\n```bash\ngit branch --merged    # Lists branches merged into current branch\ngit branch --no-merged # Lists branches NOT merged\n```",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6020,
            "displayId": "GIT-20",
            "front": "What is the recommended **git workflow** for team collaboration using branches?",
            "back": "**Recommended workflow (Git Flow variant):**\n\n1. **Create a feature branch** from `main` or `develop`:\n   ```bash\n   git checkout -b feature/user-auth\n   ```\n\n2. **Make commits** with clear, descriptive messages:\n   ```bash\n   git commit -m \"Add login form validation\"\n   ```\n\n3. **Push the branch** to remote:\n   ```bash\n   git push origin feature/user-auth\n   ```\n\n4. **Create a Pull Request (PR)** on GitHub/GitLab for code review\n\n5. **Address review feedback** with additional commits\n\n6. **Merge the PR** once approved (usually via `git merge --no-ff` to preserve history)\n\n7. **Delete the branch** after merging:\n   ```bash\n   git branch -d feature/user-auth\n   git push origin --delete feature/user-auth\n   ```\n\n**Key principles:**\n- One feature per branch\n- Keep branches short-lived (1-3 days of work)\n- Always use pull requests for code review\n- Never force-push to shared branches\n- Maintain descriptive branch names\n- Sync frequently with main to avoid conflicts",
            "category": "Branching & Merging",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-11",
        "title": "Chapter 3: Collaboration and Remote Repositories",
        "cards": [
          {
            "id": 6021,
            "displayId": "GIT-21",
            "front": "What is a **git remote**, and how do you view all configured remotes for a repository?",
            "back": "A **git remote** is a reference to a remote repository (typically on a server like GitHub). It stores the URL and name of the remote location.\n\nTo view all configured remotes, use:\n```bash\ngit remote -v\n```\n\nThis displays both fetch and push URLs. The default remote is usually named `origin`. Add a new remote with:\n```bash\ngit remote add <name> <url>\n```",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6022,
            "displayId": "GIT-22",
            "front": "What does **`git clone`** do, and how does it differ from **`git init`**?",
            "back": "**`git clone`** downloads an entire remote repository to your local machine, including all commits, branches, and history:\n```bash\ngit clone <repository-url>\n```\n\n**`git init`** initializes a new, empty local repository from scratch.\n\n**Key differences:**\n- `clone` is for copying existing repositories; `init` creates a new one\n- `clone` automatically sets up the remote (`origin`); `init` requires manual remote configuration\n- `clone` includes full project history; `init` starts fresh\n\nUse `clone` to contribute to existing projects, `init` to start new projects.",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6023,
            "displayId": "GIT-23",
            "front": "Explain the difference between **`git fetch`** and **`git pull`**.",
            "back": "**`git fetch`** downloads commits and branches from the remote repository but does NOT merge them into your local branches:\n```bash\ngit fetch origin\n```\nIt updates remote-tracking branches (e.g., `origin/main`) safely.\n\n**`git pull`** performs both `fetch` and `merge` automatically:\n```bash\ngit pull origin main\n```\n\n**Key differences:**\n- `fetch` is safe; it won't modify your working directory or local branches\n- `pull` automatically merges, which can cause merge conflicts\n- Use `fetch` when you want to review changes before merging\n- Use `pull` for quick integration when you trust the remote changes\n\n**Best practice:** Use `fetch` then review with `git diff origin/main` before merging manually.",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6024,
            "displayId": "GIT-24",
            "front": "What is the purpose of **`git push`**, and how do you push a new branch to a remote?",
            "back": "**`git push`** uploads your local commits to a remote repository:\n```bash\ngit push origin main\n```\n\nThis updates the remote branch to match your local branch.\n\n**To push a new local branch to the remote:**\n```bash\ngit push -u origin feature-branch\n```\n\nThe `-u` (or `--set-upstream`) flag:\n- Creates the branch on the remote\n- Sets up tracking so future `git pull` knows which remote branch to use\n- Without `-u`, you must specify the branch name in future pushes\n\n**Common scenarios:**\n- Push to existing remote branch: `git push origin main`\n- Push a new branch: `git push -u origin my-feature`\n- Push all branches: `git push origin --all`\n- Push with force (dangerous): `git push origin main --force` (overwrites remote history)",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6025,
            "displayId": "GIT-25",
            "front": "What is a **pull request (PR)**, and what is the typical workflow for creating and reviewing one on GitHub?",
            "back": "A **pull request (PR)** is a proposal to merge changes from one branch into another (typically from a feature branch into `main`). It enables code review and discussion before integration.\n\n**GitHub PR workflow:**\n\n1. **Create a feature branch:** `git checkout -b feature-branch`\n2. **Make commits** with descriptive messages\n3. **Push to remote:** `git push -u origin feature-branch`\n4. **Open PR on GitHub:** Click \"Compare & pull request\" and write a clear description\n5. **Request reviewers:** Assign team members to review\n6. **Address feedback:** Make additional commits based on review comments\n7. **Merge:** Once approved, click \"Merge pull request\"\n8. **Delete branch:** Clean up by deleting the feature branch\n\n**Benefits:**\n- Code quality through peer review\n- Documentation via PR description\n- Discussion and knowledge sharing\n- CI/CD integration for automated testing",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6026,
            "displayId": "GIT-26",
            "front": "Explain the concept of **upstream** vs **origin** in Git. How do they differ?",
            "back": "**`origin`** is the default remote that points to YOUR fork or clone of the repository (typically on your GitHub account).\n\n**`upstream`** is an additional remote that points to the ORIGINAL repository from which you forked (the maintainer's repo).\n\n**Setup for contributed projects:**\n```bash\ngit remote add upstream https://github.com/original-owner/repo.git\ngit remote -v  # Shows both origin and upstream\n```\n\n**Typical workflow:**\n```bash\ngit fetch upstream          # Get latest from original repo\ngit rebase upstream/main    # Update your local branch\ngit push origin main        # Push to your fork\n```\n\n**Why both are needed:**\n- `origin` = your working copy (push here)\n- `upstream` = source of truth (pull latest changes from here)\n- Keeps your fork synced with the original project\n- Prevents divergence in long-term contributions",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6027,
            "displayId": "GIT-27",
            "front": "What are the risks of **force pushing**, and when is it safe to use **`git push --force`**?",
            "back": "**`git push --force`** overwrites remote history, discarding any commits not in your local branch. This is **dangerous** because:\n- Other developers' work may be lost\n- History becomes inconsistent across the team\n- Difficult to recover deleted commits\n- Causes merge conflicts for collaborators\n\n**When force push is safe:**\n- **Unpublished branches:** Feature branches not yet merged (confirm no one else is using it)\n- **Your own fork:** In your personal repository\n- **Before PR merge:** On a branch awaiting review\n- **After explicit team agreement:** With communication\n\n**Safer alternatives:**\n```bash\ngit push --force-with-lease  # Only overwrites if remote matches your last fetch\ngit revert <commit>          # Undoes changes with a new commit (preserves history)\ngit reset --soft HEAD~1      # Undo last commit locally (doesn't affect remote yet)\n```\n\n**Golden rule:** Never force push to `main` or shared branches. Use caution even on feature branches.",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6028,
            "displayId": "GIT-28",
            "front": "What does it mean when **`git push` is rejected**, and what are the common causes and solutions?",
            "back": "**Push rejection** occurs when the remote refuses your push. Common causes and solutions:\n\n**1. Remote has commits you don't have:**\n```bash\ngit fetch origin              # Download remote changes\ngit rebase origin/main        # Rebase your commits on top\ngit push origin main          # Now push will succeed\n```\n\n**2. Branch protection rules** (e.g., requiring PR review):\n- Create a PR instead of pushing directly\n\n**3. Insufficient permissions:**\n- Ensure you have write access to the repository\n\n**4. Authentication failure:**\n- Check SSH keys or GitHub credentials\n\n**5. Large files or history violations:**\n- Repository may reject large files or sensitive data\n\n**Prevention strategies:**\n- `git pull --rebase` before pushing\n- `git fetch` regularly to stay updated\n- Use `git status` to check current state\n- Follow team conventions\n\n**Never use `--force` to resolve rejection.** It indicates you're out of sync; always merge/rebase first.",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6029,
            "displayId": "GIT-29",
            "front": "Describe a typical **GitHub collaborative workflow** for a team working on the same project.",
            "back": "**Typical GitHub team workflow:**\n\n1. **Create a feature branch** from `main`:\n```bash\ngit checkout main\ngit pull origin main\ngit checkout -b feature/user-auth\n```\n\n2. **Make commits** with clear messages:\n```bash\ngit add .\ngit commit -m \"Add login form and validation\"\n```\n\n3. **Push to remote:**\n```bash\ngit push -u origin feature/user-auth\n```\n\n4. **Open Pull Request** on GitHub with description\n\n5. **CI/CD runs:** Automated tests, linting, and builds\n\n6. **Code review:** Team members comment and request changes\n\n7. **Address feedback:** Make additional commits, tests pass\n\n8. **Merge:** Maintainer approves and merges to `main`\n\n9. **Delete branch:** Clean up completed feature branch\n\n**Best practices:**\n- One feature per branch\n- Small, focused PRs (easier to review)\n- Descriptive commit messages\n- Require reviews before merging\n- Protect `main` branch (no direct pushes)\n- Use consistent naming conventions\n- Deploy merged code to production",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6030,
            "displayId": "GIT-30",
            "front": "How do you **synchronize your fork with the upstream repository** to prevent it from falling behind?",
            "back": "**Keeping your fork in sync with upstream:**\n\n1. **Add upstream remote** (if not already done):\n```bash\ngit remote add upstream https://github.com/original-owner/repo.git\n```\n\n2. **Fetch latest from upstream:**\n```bash\ngit fetch upstream\n```\n\n3. **Rebase your branch on upstream/main:**\n```bash\ngit checkout main\ngit rebase upstream/main\n```\n\n4. **Push updated main to your fork:**\n```bash\ngit push origin main\n```\n\n**Alternative: Merge instead of rebase:**\n```bash\ngit merge upstream/main\ngit push origin main\n```\n\n**Rebase vs Merge:**\n- **Rebase** (preferred): Creates linear history, cleaner logs\n- **Merge** (safer): Preserves all commits, easier to understand what happened\n\n**Automating with GitHub:**\n- Some projects enable \"Allow auto-merge on pull requests\"\n- Use GitHub Actions to auto-sync forks\n- Or set up a scheduled workflow to keep forks updated\n\n**Check sync status:**\n```bash\ngit log --oneline upstream/main..origin/main  # Commits ahead\ngit log --oneline origin/main..upstream/main  # Commits behind\n```",
            "category": "Remote Repositories",
            "frontImage": null,
            "backImage": null
          }
        ]
      },
      {
        "id": "deck-12",
        "title": "Chapter 4: Git Worktree",
        "cards": [
          {
            "id": 6031,
            "displayId": "WT-01",
            "front": "What is a **git worktree** and what problem does it solve?",
            "back": "A **git worktree** enables multiple working trees from a single repository, allowing you to work on different branches simultaneously without the friction of stashing and switching.\n\n**The Problem**:\nTraditional stash workflow requires context switching:\n```bash\n# Old approach - context gets lost\ngit stash               # ❌ Lose your working context\ngit checkout bugfix\n# ... work on bugfix ...\ngit checkout feature\ngit stash pop           # ❌ May have conflicts\n```\n\n**The Solution**:\nWorktree approach preserves context:\n```bash\n# New approach - context preserved\ngit worktree add ../bugfix bugfix\n# ... work on bugfix in separate directory ...\ncd ../feature           # ✅ Context still intact\n# Continue your work\n```\n\n**Key Benefits**:\n- Parallel work on multiple branches\n- No context loss or stashing needed\n- Shared object database (efficient disk usage)\n- Isolated working environments",
            "category": "Fundamentals",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6032,
            "displayId": "WT-02",
            "front": "How do **git worktrees** compare to **separate clones** in terms of resource usage?",
            "back": "**Git Worktrees** vs **Separate Clones**:\n\n| Aspect | Worktree | Clone |\n|--------|----------|-------|\n| **Disk Space** | Minimal (~MB) | Full duplicate (~100s MB+) |\n| **Setup Time** | Seconds | Minutes |\n| **Object Database** | Shared (.git) | Independent |\n| **Remote Tracking** | Shared refs | Independent |\n| **Use Case** | Short to medium-term | Long-term fork |\n\n**Disk Space Example**:\n```bash\n# Repository size: 500MB\n\n# Approach 1: Separate Clones\ngit clone repo repo1        # 500MB\ngit clone repo repo2        # 500MB\ngit clone repo repo3        # 500MB\n# Total: 1.5GB\n\n# Approach 2: Worktrees (✅ Much smaller)\ngit worktree add ../wt1 branch1   # ~5MB extra\ngit worktree add ../wt2 branch2   # ~5MB extra\ngit worktree add ../wt3 branch3   # ~5MB extra\n# Total: 515MB\n```\n\n**Why Worktrees Are Better**:\n- ✅ Share one `.git` object database\n- ✅ Only per-worktree files (HEAD, index, logs)\n- ✅ Fast to create and remove\n- ✅ Efficient for team workflows",
            "category": "Comparison",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6033,
            "displayId": "WT-03",
            "front": "Explain **main worktree** vs **linked worktree** architecture.",
            "back": "**Main Worktree** (created by `git init` or `git clone`):\n- Contains the actual `.git/` directory\n- Stores all Git metadata and objects\n- Central reference point for all linked worktrees\n- Cannot be deleted while linked worktrees exist\n\n**Linked Worktree** (created by `git worktree add`):\n- References the main worktree via a `.git` file (not a directory)\n- Shares object database and refs from main\n- Has per-worktree files (HEAD, index, logs)\n- Can be deleted independently\n\n**Directory Structure**:\n```bash\nrepository/                 # Main worktree\n├── .git/                   # ✅ Real directory with all Git data\n│   ├── objects/\n│   ├── refs/\n│   └── worktrees/          # Admin files for linked worktrees\n│       ├── hotfix/\n│       └── feature/\n├── src/\n└── README.md\n\nworktrees/                  # Separate directory for linked worktrees\n├── hotfix/                 # Linked worktree 1\n│   └── .git               # ❌ FILE (not directory) pointing to main\n│   ├── src/\n│   └── README.md\n└── feature/               # Linked worktree 2\n    └── .git              # ❌ FILE (not directory) pointing to main\n    ├── src/\n    └── README.md\n```\n\n**Key Point**: All worktrees share the same `.git/objects/` to save disk space, but each has its own working context.",
            "category": "Architecture",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6034,
            "displayId": "WT-04",
            "front": "What is the **one branch per worktree** constraint and why does it exist?",
            "back": "**The Constraint**:\nBy default, Git prevents checking out the same branch in multiple worktrees simultaneously.\n\n**Error You Get**:\n```bash\ncd repository\ngit worktree add ../feature main\n# Error: fatal: 'main' is already checked out at '[path]'\n```\n\n**Why This Constraint Exists**:\nThe same branch can only be checked out in one place to prevent:\n- Concurrent file modifications (data loss)\n- Index conflicts\n- HEAD confusion\n\n**Valid Approaches**:\n\n✅ **Create new branch for worktree**:\n```bash\ngit worktree add -b new-feature ../feature\n# Creates new-feature branch and checks it out\n```\n\n✅ **Use different existing branch**:\n```bash\ngit worktree add ../hotfix hotfix-branch\n# hotfix-branch is not checked out elsewhere\n```\n\n✅ **Use detached HEAD**:\n```bash\ngit worktree add -d ../testing abc1234\n# Detached at specific commit, no branch conflict\n```\n\n❌ **Force override (risky)**:\n```bash\ngit worktree add --force ../duplicate main\n# Not recommended - risk of data loss!\n```\n\n**Best Practice**: Always create new branches or use different branches for each worktree to avoid this constraint.",
            "category": "Constraints",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6035,
            "displayId": "WT-05",
            "front": "What are the **three essential git worktree commands** for basic usage?",
            "back": "**1. git worktree add** - Create a new worktree:\n```bash\n# Syntax\ngit worktree add <path> [<branch>]\n\n# Example: Add worktree for existing branch\ngit worktree add ../bugfix bugfix-123\n\n# Example: Create new branch and worktree\ngit worktree add -b feature/payment ../payment\n\n# Example: Detached HEAD at commit\ngit worktree add -d ../testing abc1234\n\n# Example: Lock immediately (prevent pruning)\ngit worktree add --lock ../temporary ../temporary\n```\n\n**2. git worktree list** - View all worktrees:\n```bash\n# Basic listing\ngit worktree list\n# Output:\n# /path/to/main (main)\n# /path/to/worktrees/hotfix (hotfix) locked\n\n# Verbose details\ngit worktree list -v\n\n# Machine-readable format\ngit worktree list --porcelain\n```\n\n**3. git worktree remove** - Delete a worktree:\n```bash\n# Normal removal (requires clean working directory)\ngit worktree remove ../hotfix\n\n# Force removal with uncommitted changes ✅ Safe\ngit worktree remove -f ../hotfix\n\n# Prune stale metadata after manual deletion ✅ Cleanup\ngit worktree prune\n```\n\n**Typical Workflow**:\n```bash\ngit worktree add -b feature/auth ../auth  # ✅ Create\ngit worktree list                         # ✅ Check\ncd ../auth && git commit ...              # Work\ngit worktree remove ../auth               # ✅ Cleanup\n```",
            "category": "Commands",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6036,
            "displayId": "WT-06",
            "front": "What are the **advanced worktree management commands**?",
            "back": "**git worktree lock** - Prevent automatic deletion:\n```bash\n# Prevent pruning (e.g., worktree on external drive)\ngit worktree lock ../external-drive-wt\n\n# Lock with reason annotation\ngit worktree lock --reason \"Portable external SSD\" ../external-wt\n\n# Check lock status\ngit worktree list -v  # Shows (locked) status\n```\n\n**git worktree unlock** - Allow operations:\n```bash\n# Re-enable pruning and removal\ngit worktree unlock ../external-drive-wt\n\n# Now can remove without lock\ngit worktree remove ../external-drive-wt\n```\n\n**git worktree prune** - Clean stale metadata:\n```bash\n# Remove metadata for missing worktrees\ngit worktree prune\n\n# Preview what would be removed\ngit worktree prune --dry-run\n\n# Only remove older than 2 weeks\ngit worktree prune --expire 2.weeks\n```\n\n**git worktree repair** - Fix broken connections:\n```bash\n# Repair all worktrees\ngit worktree repair\n\n# Repair specific worktree\ngit worktree repair /path/to/worktree\n\n# Example: After manually moving directory\nmv /users/dev/worktree /users/dev/work/worktree\ngit worktree repair  # ✅ Fixes broken references\n```\n\n**When to Use Each**:\n- **lock**: Worktree on removable/external media\n- **unlock**: Before removing locked worktree\n- **prune**: After manual directory deletion\n- **repair**: After moving directories or restoring from backup",
            "category": "Management",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6037,
            "displayId": "WT-07",
            "front": "What are **best practices for organizing worktrees**?",
            "back": "**Organization Strategy**:\nUse a dedicated directory for all worktrees and match directory names to branch names.\n\n**✅ Recommended Structure**:\n```bash\nrepository/\n├── .git/\n├── src/\n├── README.md\n└── worktrees/                  # Dedicated worktrees directory\n    ├── feature-auth/           # Feature development\n    ├── hotfix-critical/        # Emergency fixes\n    ├── review-pr-123/          # PR reviews\n    └── experimental/           # Experimental features\n```\n\n**Setup Commands**:\n```bash\n# Create organized worktrees\ngit worktree add -b feature/authentication ./worktrees/feature-auth\ngit worktree add -b hotfix/security ./worktrees/hotfix-critical\ngit worktree add -d ./worktrees/review                # Detached for testing\n```\n\n**Naming Conventions**:\n```bash\n# ✅ Clear naming\ngit worktree add ./worktrees/feature-payment -b feature/payment-system\ngit worktree add ./worktrees/fix-docker -b bugfix/docker-build\ngit worktree add ./worktrees/review-team-pr ./worktrees/review-team-pr\n\n# ❌ Confusing naming\ngit worktree add ./w1 feature/payment-system\ngit worktree add ./tmp bugfix/docker-build\ngit worktree add ./t3 ./worktrees/review-team-pr\n```\n\n**Cleanup Strategy**:\n```bash\n# View all active worktrees\ngit worktree list\n\n# Remove completed worktrees\ngit worktree remove ./worktrees/feature-auth\n\n# Periodically clean stale metadata\ngit worktree prune --dry-run\ngit worktree prune\n```\n\n**Why This Matters**:\n- ✅ Easy to understand project structure\n- ✅ Prevents scattered directories\n- ✅ Helps team members find worktrees\n- ✅ Simple cleanup process",
            "category": "Best Practices",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6038,
            "displayId": "WT-08",
            "front": "How do you implement a **feature development + code review workflow** with worktrees?",
            "back": "**Setup: Create Permanent Worktrees**\n\n```bash\n# Create three dedicated worktrees\ngit worktree add ./worktrees/main main          # Reference read-only copy\ngit worktree add ./worktrees/dev -b develop    # Main development branch\ngit worktree add ./worktrees/review develop    # Code review environment\n```\n\n**Workflow: Feature Development**\n\n```bash\n# Step 1: Work on feature in dev worktree\ncd ./worktrees/dev\ngit checkout -b feature/payment-system\n# ... make changes, commit, run tests ...\ngit commit -m \"Add payment processing\"\n\n# Step 2: Push feature to GitHub\ngit push origin feature/payment-system\n# Create pull request\n```\n\n**Workflow: Code Review (without interrupting development)**\n\n```bash\n# Step 1: PR arrives - fetch without leaving dev worktree\ncd ./worktrees/review\ngit fetch origin pull/123/head:review-pr-123\ngit checkout review-pr-123\n\n# Step 2: Test the PR\nnpm install && npm test\n# Leave feedback on GitHub\n\n# Step 3: Return to feature work\ncd ../dev\n# ✅ Your feature context is still intact!\n```\n\n**Workflow: Production Bug Fix**\n\n```bash\n# Emergency hotfix without interrupting feature work\ngit worktree add ./worktrees/hotfix main\n\ncd ./worktrees/hotfix\ngit checkout -b hotfix/critical-security-issue\n# ... fix and test ...\ngit commit -m \"Fix security issue\"\ngit push origin hotfix/critical-security-issue\n\n# Return to feature\ncd ../dev\n# ✅ Still on feature/payment-system with all changes intact\n```\n\n**Benefits**:\n- ✅ No context switching with stash\n- ✅ Multiple tasks in parallel\n- ✅ Clean separation of concerns\n- ✅ Better focus and productivity",
            "category": "Workflows",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6039,
            "displayId": "WT-09",
            "front": "What are **common worktree pitfalls** and how do you avoid them?",
            "back": "**Pitfall 1: Branch Already Checked Out**\n\nProblem:\n```bash\ngit worktree add ../feature main\n# ❌ Error: 'main' is already checked out at '[path]'\n```\n\nSolution:\n```bash\n# ✅ Create new branch\ngit worktree add -b feature/new-feature ../feature\n\n# ✅ Or use different branch\ngit worktree add ../hotfix hotfix-branch\n\n# ✅ Or check what's checked out first\ngit worktree list  # See which branches are in use\n```\n\n**Pitfall 2: Manual Directory Deletion**\n\nProblem:\n```bash\nrm -rf ./worktrees/feature-old/\ngit worktree list\n# ❌ Still shows the deleted worktree!\n```\n\nSolution:\n```bash\n# ✅ Always use git command\ngit worktree remove ./worktrees/feature-old\n\n# ✅ If already manually deleted, cleanup metadata\ngit worktree prune\n```\n\n**Pitfall 3: Locked Worktree Issues**\n\nProblem:\n```bash\ngit worktree lock ../external-drive-wt\nrm -rf ../external-drive-wt\n# ❌ Cannot remove - still locked\n```\n\nSolution:\n```bash\n# ✅ Unlock before removing\ngit worktree unlock ../external-drive-wt\ngit worktree remove ../external-drive-wt\n```\n\n**Pitfall 4: Forgetting to Check Current Location**\n\nProblem:\n```bash\n# You think you're in feature worktree\ngit checkout main\n# ❌ Actually modified main branch in dev worktree!\n```\n\nSolution:\n```bash\n# ✅ Always check your location\npwd                  # See directory\nls .git              # FILE = linked worktree, DIR = main\ngit worktree list   # See what's checked out where\n```\n\n**Prevention Checklist**:\n- ✅ Always use `git worktree add` for creation\n- ✅ Always use `git worktree remove` for deletion\n- ✅ Check `git worktree list` before adding\n- ✅ Unlock worktrees before removing\n- ✅ Clean stale metadata with `git worktree prune`",
            "category": "Pitfalls",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6040,
            "displayId": "WT-10",
            "front": "What are **detached HEAD worktrees** and when would you use them?",
            "back": "**Detached HEAD Worktree**:\nA worktree checked out at a specific commit instead of a branch.\n\n**Create Detached HEAD Worktree**:\n```bash\n# At specific commit\ngit worktree add -d ../testing abc1234\n\n# At tag\ngit worktree add -d ../test-v1.0 v1.0\n\n# At branch (but detached, not tracking)\ngit worktree add -d ../parallel-test main\n```\n\n**Use Case 1: Parallel Testing on Same Commit**\n\n```bash\n# Development: Feature work on main branch\ngit worktree add -b feature/api ../dev\ncd ../dev\n# ... work on feature ...\n\n# Meanwhile: Fuzz testing on specific main commit\ngit worktree add -d ../fuzz-test main\ncd ../fuzz-test\n# Run long-running fuzz tests\n\n# Result: ✅ Both run simultaneously without conflict\n```\n\n**Use Case 2: Version-Specific Testing**\n\n```bash\n# Test current code against multiple versions\ngit worktree add -d ../test-v1.0 v1.0\ngit worktree add -d ../test-v1.1 v1.1\ngit worktree add -d ../test-v2.0 v2.0\n\n# Run compatibility tests on each version independently\n```\n\n**Use Case 3: Bisect Debugging**\n\n```bash\n# Find which commit introduced a bug\ngit worktree add -d ../bisect HEAD  # Start point\ncd ../bisect\ngit bisect start\n# Test different commits without losing main context\n```\n\n**Advantages Over Branches**:\n- ✅ No branch constraints (same branch in multiple worktrees)\n- ✅ Temporary point-in-time environment\n- ✅ Clean for exploratory testing\n- ✅ No risk of branch modifications\n\n**Disadvantages**:\n- ❌ Cannot commit (detached HEAD)\n- ❌ Must checkout branch if changes needed\n- ❌ More temporary than permanent worktrees",
            "category": "Advanced",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6041,
            "displayId": "WT-11",
            "front": "How do you **move a worktree** and **repair broken connections**?",
            "back": "**git worktree move** - Relocate Worktree Directory\n\n```bash\n# Move worktree to new location\ngit worktree move <old-path> <new-path>\n\n# Example: Organize to subdirectory\ngit worktree move ../my-feature ./worktrees/my-feature\n\n# Limitations:\n# - Cannot move main worktree\n# - Worktrees with submodules need repair\n```\n\n**git worktree repair** - Fix Broken Connections\n\n```bash\n# Repair all broken worktree connections\ngit worktree repair\n\n# Repair specific worktree\ngit worktree repair /path/to/worktree\n\n# Check what would be repaired\ngit worktree list --porcelain\n```\n\n**Scenario: After Moving Directory Manually**\n\n```bash\n# Original location\n/Users/dev/project/\n├── .git/\n└── worktrees/\n    └── feature/\n\n# You move entire project\nmv /Users/dev/project /Users/dev/work/project\n\n# Now git worktree commands fail\ncd /Users/dev/work/project\ngit worktree list\n# ❌ Error: Cannot read admin files\n\n# Solution: Repair connections\ngit worktree repair\n# ✅ All worktrees functional again\n```\n\n**Scenario: After Copying to External Drive**\n\n```bash\n# Copy project to external SSD\ncp -r project/ /Volumes/SSD/project/\ncd /Volumes/SSD/project\ngit worktree list\n# ❌ Broken references\n\n# Repair\ngit worktree repair\n# ✅ Works with worktrees on external drive\n\n# Lock to prevent automatic pruning\ngit worktree lock ./worktrees/feature\n```\n\n**When You Need Move/Repair**:\n- ✅ Reorganizing directory structure\n- ✅ Moving to external/portable drive\n- ✅ Copying project for backup\n- ✅ Restoring from version control\n\n**Prevention**:\n```bash\n# Use git command instead of manual mv\ngit worktree move ../feature ./worktrees/feature  # ✅ Safe\n\n# NOT this:\nmv ../feature ./worktrees/feature                # ❌ Breaks refs\n```",
            "category": "Maintenance",
            "frontImage": null,
            "backImage": null
          },
          {
            "id": 6042,
            "displayId": "WT-12",
            "front": "**Complete Git Worktree Workflow**: Team Collaboration Scenario",
            "back": "**Scenario**: Developer working on feature while teammates submit PRs\n\n**Setup Phase**:\n```bash\n# Clone and create organized worktree structure\ngit clone https://github.com/company/app.git\ncd app\n\n# Create permanent worktrees\ngit worktree add ./worktrees/main main\ngit worktree add -b develop ./worktrees/develop\ngit worktree add ./worktrees/review main    # For PR reviews\ngit worktree add ./worktrees/hotfix main    # For urgent fixes\n\nls -la ./worktrees/\n# feature-auth/\n# develop/\n# review/\n# hotfix/\n```\n\n**Development Phase**:\n```bash\ncd ./worktrees/develop\ngit checkout -b feature/payment-integration\n\n# Make changes\necho \"payment code\" >> src/payment.js\ngit add .\ngit commit -m \"Add Stripe integration\"\n\n# Push and create PR\ngit push origin feature/payment-integration\n```\n\n**PR Review Phase (without interrupting development)**:\n```bash\n# Teammate submits PR #42\ncd ./worktrees/review\n\n# Fetch the PR\ngit fetch origin pull/42/head:review-pr-42\ngit checkout review-pr-42\n\n# Test the PR\nnpm install && npm test\n# ✅ All tests pass, approve PR\n\n# Return to development\ncd ../develop\n# ✅ Your feature changes are still here!\ngit status\n# On branch feature/payment-integration\n# Your changes: still present\n```\n\n**Emergency Hotfix Phase**:\n```bash\n# Production bug discovered!\ncd ./worktrees/hotfix\ngit checkout -b hotfix/payment-crash main\n\n# Quick fix\necho \"fix\" >> src/payment.js\ngit commit -am \"Fix payment crash\"\ngit push origin hotfix/payment-crash\n\n# Create PR for immediate merge\n\n# Return to feature work\ncd ../develop\n# ✅ Still on feature/payment-integration\n# ✅ All your changes intact\n```\n\n**Complete Cleanup**:\n```bash\n# When feature is merged\ncd ./worktrees/main\ngit pull origin main\n\n# Remove completed worktrees\ngit worktree remove ./worktrees/develop\ngit worktree remove ./worktrees/hotfix\n\n# Keep review worktree for next PR\n\n# Cleanup stale metadata\ngit worktree prune\n```\n\n**Benefits Demonstrated**:\n- ✅ No context loss between tasks\n- ✅ Parallel work on features, reviews, hotfixes\n- ✅ Easy context switching (just `cd`)\n- ✅ Clean separation of concerns\n- ✅ Professional workflow that scales",
            "category": "Real-world Workflows",
            "frontImage": null,
            "backImage": null
          }
        ]
      }
    ]
  }
]